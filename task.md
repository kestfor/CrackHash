# Предисловие

Мы стремимся реализовать распределенную систему для взлома хэша под кодовым именем CrackHash. Непосредственно взлом хэша будем реализовывать через простой перебор словаря сгенерированного на основе алфавита (brute-force). В общих чертах система должна работать по следующей логике:

В рамках системы существует менеджер, который принимает от пользователя запрос, содержащий MD-5 хэш некоторого слова, а также его максимальную длину.

Менеджер обрабатывает запрос: генерирует задачи в соответствии с заданным числом воркеров (вычислительных узлов) на перебор слов составленных из переданного им алфавита. После чего отправляет их на исполнение воркерам.

Каждый воркер принимает задачу, перебирает слова в заданном диапазоне и вычисляет их хэш. Находит слова у которых хеш совпадает с заданным, и результат работы возвращает менеджеру через очередь.

## Task 1.  Services Implementation

В рамках первой лабораторной работы необходимо реализовать приложения менеджера и воркера, а также организовать простое их взаимодействие через HTTP.

**Примечание:**
Настройка очередей и producer-ов/listener-ов для них в рамках данной задачи не предполагается!

### Общие требования:

Система состоит из двух типов сервисов:

- Менеджер (Manager) — принимает запросы от клиента, управляет обработкой и агрегирует результаты.
- Воркеры (Worker) — выполняют перебор слов в заданной части пространства и ищут совпадения по хэшу.

Общая логика работы системы:

1. Клиент отправляет менеджеру MD5-хэш и максимальную длину искомого слова.
2. Менеджер создаёт запрос, разбивает задачу на подзадачи и отправляет их воркерам.
3. Воркеры выполняют перебор слов и возвращают найденные совпадения.
4. Менеджер агрегирует ответы и предоставляет клиенту результат.

Все сервисы должны запускаться с использованием docker-compose.

Менеджер и воркеры должны быть реализованы как отдельные приложения с собственными Dockerfile.

Взаимодействие между сервисами осуществляется по протоколу HTTP внутри сети docker-compose с использованием имён сервисов в качестве хостов.

*Язык программирования и технологический стек выбираются самостоятельно.

### Формат взаимодействия

Для обмена данными допускается использование JSON или XML.
Система обязана поддерживать хотя бы один формат.

### Алфавит и пространство перебора

Перебор должен выполняться для строк, состоящих из заданного алфавита в конфигурации:

- строчных латинских букв a–z;
- цифр 0–9.

Длина строк — от 1 до maxLength включительно.

Способ генерации слов и разбиения пространства перебора между воркерами не регламентируется. Реализация должна обеспечивать обработку всех возможных комбинаций в заданном диапазоне длин.

### Логирование

В системе должно присутствовать логирование, позволяющее при демонстрации работы проследить:

- прием запроса от клиента;
- распределение задач между воркерами;
- процесс выполнения задач;
- формирование итогового результата.

Формат и детализация логов определяются студентом.

### Документация

В репозитории должен присутствовать README.md, содержащий:

- описание архитектуры системы;
- схему взаимодействия компонентов (можно нарисовать в draw.io);
- инструкцию по запуску;
- описание API и примеры запросов;
- описание используемых конфигурационных параметров.

## 2. Требования к менеджеру

Менеджер должен предоставлять клиенту REST API в формате для взаимодействия с ним.

Пример запроса на взлом хэша (слово abcd):

```
POST /api/hash/crack
```

Request body:

```json
{
  "hash":"e2fc714c4727ee9395f324cd2e7f331f",
  "maxLength": 4
}
```

В ответ менеджер должен отдавать клиенту идентификатор запроса, по которому тот сможет обратится за получением ответа.

Пример ответа:

Response body:

```json
{
  "requestId":"730a04e6-4de9-41f9-9d5b-53b88b17afac"
}
```

После получения запроса менеджер должен:

1. Создать внутреннюю запись о запросе.
2. Перевести его в статус IN_PROGRESS.
3. Разбить задачу на части.
4. Отправить подзадачи воркерам.

Информация о запросах хранится в оперативной памяти с использованием потокобезопасных структур данных.

Все числовые параметры (таймаут обработки, количество воркеров и т.п.) должны задаваться через конфигурацию.

Для получения результатов менеджер должен представлять следующее API.

Пример:

```
GET /api/hash/status?requestId=<UUID>
```

Ответ,  если запрос еще обрабатывается.

Response body:

```json
{
  "status":"IN_PROGRESS",
  "progress": 65,
  "data": null
}
```

Ответ,  если ответ готов.

Response body:

```json
{
  "status":"READY",
  "progress": 100,
  "data": ["abcd"]
}
```

При возникновении ошибки (таймаут, недоступность сервисов и др.) запрос должен переводиться в статус ERROR.

Ответ должен содержать:

- статус обработки;
- найденные слова (если имеются);
- текущий прогресс выполнения.

Возможные статусы:

- IN_PROGRESS
- READY
- ERROR

### 2.1. Взаимодействие с воркерами

Менеджер должен отправлять задачи воркерам через internal API и принимать от них результаты.

## Требования к воркерам:

Воркеры предназначены для выполнения перебора слов в рамках полученной задачи.

Каждый воркер:

1. Принимает задачу от менеджера.
2. Генерирует слова в пределах назначенного диапазона.
3. Вычисляет MD5-хэш для каждой строки.
4. При совпадении сохраняет найденные значения.
5. Отправляет результат менеджеру.

Воркеры не должны хранить в памяти всё пространство комбинаций целиком. Генерация должна осуществляться итеративно.

Алфавит может быть задан в конфигурации воркера.

Количество воркеров должно быть легко и быстро конфигурируемым, по дефолту 3.

### 3.1 Internal API воркера

Воркеры должны принимать задачи по пути:

```
POST /internal/api/worker/hash/crack/task
```

Для internal API воркера обязательно наличие Swagger (OpenAPI) документации.

Структура запроса и ответа определяется студентом самостоятельно.

## Полезные ссылки:

Пример базового сервиса на Spring
https://spring-projects.ru/guides/rest-service/

База про XSD
https://www.codeguru.com/java/xsd-tutorial-xml-schemas-for-beginners/

XSD спецификация
https://www.w3.org/TR/xmlschema11-1/

Пример генерации JAXB моделей на основе xsd
https://spring.io/guides/gs/producing-web-service/

Генерация последовательностей
https://github.com/dpaukov/combinatoricslib

Rest Template
https://docs.spring.io/spring-android/docs/current/reference/html/rest-template.html
https://www.baeldung.com/rest-template

JAXB + Rest Template
https://stackoverflow.com/questions/41288036/how-do-i-use-jaxb-annotations-with-spring-resttemplate